# -*- coding: utf-8 -*-

from .timing import WorkflowTiming

__author__ = "Romain Mormont <romainmormont@hotmail.com>"
__version__ = "0.1"


class ChainInformation(object):
    """ A class for storing information gathered at various stages of execution of a workflow chain.
    """
    def __init__(self):
        self._order = []
        self._infos = dict()

    def __len__(self):
        return len(self._order)

    def __setitem__(self, key, value):
        """Set a workflow information object with the given label. If the label already exists, the previously
        recorded workflow information is overwritten.

        Parameters
        ----------
        key: hashable
            The label of the workflow that generated the
        value: WorkflowInformation
            The workflow information
        """
        if key not in self._infos:
            self._order.append(key)
        self._infos[key] = value

    def __getitem__(self, item):
        """Get the workflow information associated with the given label

        Parameters
        ----------
        item: hashable
        :return:
        """
        return self._infos[item]

    def all_information(self):
        """Yields all the registered workflow information objects

        Yields
        ------
        label: hashable
            The label associated with the workflow which generated the information object
        information: WorkflowInformation
            A workflow information
        """
        for key in self._infos:
            yield key, self._infos[key]

    def information(self, label):
        """Get the information generated by the workflow associated with the given label

        Parameters
        ----------
        label: hashable
            The label

        Returns
        -------
        information: WorkflowInformation
            TheA workflow information
        """
        return self[label]

    def append(self, label, information):
        """Append a new workflow information object to the chain information (if the label already exist, the
        the corresponding

        Parameters
        ----------
        label: hashable
            The label of the workflow which generated the workflow information object
        information: WorkflowInformation
            The workflow information object
        """
        self[label] = information

    def polygons(self):
        """Yields all polygons stored in the chain information object

        Yields
        ------
        label: hashable
            The label identifying the workflow which generated the polygon
        polygon: shapely.geometry.Polygon
            A polygon
        dispatch: hashable
            The label of the dispatching rule which dispatched the polygon
        class: int
            The class predicted for this polygon
        probability: float
            The probability estimates for predicted class
        """
        for key, information in self.all_information():
            for polygon, dispatch, cls, proba in information:
                yield key, polygon, dispatch, cls, proba

    def __iter__(self):
        for k, p, d, c, r in self.polygons():
            yield k, p, d, c, r


class WorkflowInformation(object):
    """Workflow information : execution about a workflow run. A run is a complete execution
    (segment, locate, dispatch and classify) of a single workflow and comprises the following information:
        - polygons : the polygons generated by a given run
        - dispatch : list of which the ith element matches the identifier of the dispatching rule that matched
            the ith polygon (either an integer or a user defined identifier), -1 if none did
        - class : list of which the ith integer is the class predicted by the classifier to
            which was dispatched the ith polygon, -1 if none did
        - probas : list of which the ith float (in [0,1]) is the probability of the ith predicted class if the
            corresponding polygon was dispatched, 0 if it wasn't dispatched
        - timing : the information about the execution time of the workflow
    """
    def __init__(self, polygons, dispatch, classes, probas, timing):
        """Construct a run object
        Parameters
        ----------
        polygons: iterable (type: shapely.geometry.Polygon, size: N)
            The polygons generated by the run
        dispatch: iterable (size: N)
            The identifiers of the dispatching rules that matched the polygons
        classes: iterable (type: int, size: N)
            Their predicted classes
        probas: iterable (type: float, size: N)
            The probabilities of the predicted classes
        timing: SLDCTiming
            Execution time information
        """
        self._polygons = polygons
        self._dispatch = dispatch
        self._classes = classes
        self._timing = timing
        self._probas = probas

    @property
    def polygons(self):
        return self._polygons

    @property
    def dispatch(self):
        return self._dispatch

    @property
    def classes(self):
        return self._classes

    @property
    def probas(self):
        return self._probas

    @property
    def metadata(self):
        return self._metadata

    @property
    def timing(self):
        return self._timing

    def __len__(self):
        return len(self.polygons)

    def __iter__(self):
        for polygon, dispatch, cls, proba in self.results():
            yield polygon, dispatch, cls, proba

    def results(self, filter_dispatch=None, filter_classes=None):
        """Yields an iterator that goes through the list of polygons of the workflow information
        The result is a tuple containing in this order the polygon, the dispatch index and the class

        Parameters
        ----------
        filter_dispatch: iterable (optional, default: [-1])
            The dispatching rule identifiers to exclude from the iterated list
        filter_classes: iterable (subtype: int, optional, default: [])
            The classes to exclude from the iterated list
        """
        if filter_dispatch is None:
            filter_dispatch = [-1]
        for polygon, dispatch, cls, proba in zip(self.polygons, self.dispatch, self.classes, self.probas):
            if (filter_dispatch is None or dispatch not in filter_dispatch) and \
                    (filter_classes is None or cls not in filter_classes):
                yield polygon, dispatch, cls, proba

    def merge(self, other):
        """Merge the other workflow information object into the current one. The id and metadata of the first are kept
        if they are set. Otherwise, the metadata and id of the other object are also merged

        Parameters
        ----------
        other: WorkflowInformation
            The workflow information object to merge
        """
        if other is None:
            return

        self._polygons += other.polygons
        self._dispatch += other.dispatch
        self._classes += other.classes
        self._probas += other.probas
        self._timing = WorkflowTiming.merge_timings(self._timing, other.timing)
